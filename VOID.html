<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="voidicon.png" type="image/png">
    <audio src="mary.mp3" autoplay loop></audio>
    <audio id="boys-audio" src="boys.mp3" loop></audio>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let inputBuffer = '';
        const targetKeyword = 'gay';
        const audioElement = document.getElementById('boys-audio');

        function playAudio() {
            document.querySelectorAll('audio').forEach(audio => {
                if (audio !== audioElement) {
                    audio.pause();
                    audio.currentTime = 0;
                }
            });

            audioElement.play();
            audioElement.loop = true;
        }

        document.addEventListener('keydown', (event) => {
            inputBuffer += event.key.toLowerCase();

            if (inputBuffer.length > targetKeyword.length) {
                inputBuffer = inputBuffer.slice(-targetKeyword.length);
            }

            if (inputBuffer === targetKeyword) {
                playAudio();
            }
        });
    });
    </script>

    <meta property="og:title" content="VOID">
    <meta property="og:description" content="A 3D web experience by Tacoguy21">
    <meta property="og:image" content="Spaceship.png">
    <meta property="og:url" content="https://tacovoidgame.netlify.app/">
    <link rel="icon" href="voidlogo.png" type="image/png">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Space Mono', monospace;
            background: #000000;
            color: #ffffff;
        }

        p, h2 {
            font-family: 'Space Mono', monospace;
        }

        .fake-popup {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 260px;
            padding: 12px;
            background-color: rgb(20, 20, 20);
            color: rgb(220, 220, 220);
            border: 7px solid rgb(80, 0, 0);
            border-radius: 5px;
            text-align: center;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .close-btn {
            position: absolute;
            top: 5px; right: 5px;
            cursor: pointer;
            color: rgb(255, 100, 100);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            z-index: 5;
        }

        #message, #completeMessage {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            z-index: 10;
        }

        #message {
            color: rgb(255, 50, 50);
            cursor: pointer;
        }

        #completeMessage {
            color: rgb(120, 140, 255);
        }

        #levelIntro {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0,0,0,0.9);
            display: none;
            z-index: 8;
        }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud">Level: 1 | Points: 0</div>

    <!-- Intro popup -->
    <div class="fake-popup" id="popup">
        <span class="close-btn" onclick="hidePopup()">X</span>
        <h2>Important Message</h2>

        <p>You are the grey cube</p>
        <p>Avoid the spikes and reach the green cube</p>
        <p>You have 0.5 seconds of invincibility at the start of each level</p>
        <p>There are 13 levels</p>
        <p>Use WASD or Arrow Keys to move</p>
        <p>Press SPACE to dash</p>
        <p>Spikes move in predictable patterns</p>
        <p>They will never spawn on top of you</p>
        <p>Click the red text to revive when dead</p>
        <p>You may close.</p>
    </div>

    <!-- Level intro text -->
    <div id="levelIntro">LEVEL 1</div>

    <!-- Fail / complete messages -->
    <div id="message" onclick="location.reload();">failed.</div>
    <div id="completeMessage">complete.</div>
<script>
    function updateSpikeMovement(deltaMs) {
    if (level <= 25) return; // no movement before level 26

    for (const s of spikes) {
        const spike = s.mesh;

        // Move spike
        spike.position.x += s.moveDir.x * s.moveSpeed * deltaMs;
        spike.position.z += s.moveDir.z * s.moveSpeed * deltaMs;

        // Bounce off arena edges
        const limit = 7;
        if (spike.position.x < -limit || spike.position.x > limit) {
            s.moveDir.x *= -1;
        }
        if (spike.position.z < -limit || spike.position.z > limit) {
            s.moveDir.z *= -1;
        }
    }
}
</script>
    <script>
    function showPopup() {
        var popup = document.getElementById('popup');
        var bodyRect = document.body.getBoundingClientRect();
        var leftPos = bodyRect.width / 2 + (Math.random() - 0.5) * (bodyRect.width / 4);
        var topPos = bodyRect.height / 2 + (Math.random() - 0.5) * (bodyRect.height / 4);
        popup.style.left = leftPos + 'px';
        popup.style.top = topPos + 'px';
        popup.style.display = 'block';
    }
    function hidePopup() {
        document.getElementById('popup').style.display = 'none';
    }
    window.onload = showPopup;
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Scene setup ---
        const SAFE_RADIUS = 1.2; // small, tight, always clear

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.08);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 1.2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
        dirLight.position.set(4, 8, 6);
        scene.add(dirLight);

        // Grid floor
        const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        // Player
        const playerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const playerMaterial = new THREE.MeshPhongMaterial({
            color: 0xbbbbbb,
            emissive: 0x222222,
            shininess: 80
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.25;
        scene.add(player);

        // Target
        const targetGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const targetMaterial = new THREE.MeshPhongMaterial({
            color: 0x66ff66,
            emissive: 0x113311,
            shininess: 100
        });
        const target = new THREE.Mesh(targetGeometry, targetMaterial);
        target.position.set(0, 0.25, -2.5);
        scene.add(target);

        let spikes = [];

        // Game state
        let level = 1;
        const maxLevel = 50;

        let points = 0;
        let levelStartTime = 0;

        let invincible = false;
        let invincibleTimeout = null;

        // Movement physics
        const velocity = new THREE.Vector3(0, 0, 0);
        const accel = 0.009;
        const maxSpeed = 0.12;
        const friction = 0.82;
        let lastMoveDir = new THREE.Vector3(0, 0, -1);

        // Dash
        let dashCooldown = 0;
        const dashCooldownTime = 1200;
        const dashStrength = 0.22;

        // Camera shake
        let shakeTime = 0;
        const shakeDuration = 200;
        const shakeIntensity = 0.12;

        const hud = document.getElementById('hud');
        const levelIntro = document.getElementById('levelIntro');

        function updateHUD() {
            hud.textContent = `Level: ${level} | Points: ${points}`;
        }

        // Prevent spikes spawning on player or target
       function isValidSpikePosition(position) {
    const distToPlayer = player.position.distanceTo(position);
    const distToTarget = target.position.distanceTo(position);

    return (
        distToPlayer > SAFE_RADIUS + 0.8 &&   // guaranteed buffer
        distToTarget > 1.5
    );
}



        // Predictable spike patterns
function createSpikesForLevel() {
    spikes.forEach(s => scene.remove(s.mesh));
    spikes = [];

    let spikeCount;

    if (level <= 10) {
        spikeCount = 3 + Math.floor(level * 0.5);
    } else if (level <= 20) {
        spikeCount = 8 + Math.floor((level - 10) * 0.7);
    } else if (level <= 35) {
        spikeCount = 15 + Math.floor((level - 20) * 0.6);
    } else {
        spikeCount = 24 + Math.floor((level - 35) * 0.5);
    }

    spikeCount = Math.min(spikeCount, 32);

    for (let i = 0; i < spikeCount; i++) {
        let spikePosition;
        do {
            spikePosition = new THREE.Vector3(
                Math.random() * 10 - 5,
                0.5,
                Math.random() * 10 - 5
            );
        } while (!isValidSpikePosition(spikePosition));

        // --- SPIKE TYPE SELECTION ---
        let geometry;
        let material = new THREE.MeshPhongMaterial({
            color: 0xAE4305,
            emissive: 0x331000,
            shininess: 60
        });

        if (level <= 5) {
            geometry = new THREE.ConeGeometry(0.22, 0.9, 24);
        } else if (level <= 10) {
            geometry = new THREE.ConeGeometry(0.25, 1.3, 24);
        } else if (level <= 15) {
            geometry = new THREE.ConeGeometry(0.35, 0.9, 24);
        } else if (level <= 20) {
            geometry = new THREE.CylinderGeometry(0.22, 0.22, 1.2, 16);
        } else if (level <= 25) {
            geometry = new THREE.ConeGeometry(0.3, 1.1, 4);
        } else if (level <= 30) {
            geometry = new THREE.CylinderGeometry(0.18, 0.18, 0.8, 12);
        } else if (level <= 35) {
            geometry = new THREE.BoxGeometry(0.25, 1.4, 0.25);
        } else if (level <= 40) {
            geometry = new THREE.OctahedronGeometry(0.35);
        } else if (level <= 45) {
            geometry = new THREE.BoxGeometry(0.15, 1.6, 0.15);
        } else {
            geometry = new THREE.ConeGeometry(0.28, 1.4, 32);
            material = new THREE.MeshPhongMaterial({
                color: 0xff4444,
                emissive: 0x550000,
                shininess: 120
            });
        }

        const spike = new THREE.Mesh(geometry, material);
        spike.position.copy(spikePosition);

        // Flip spikes upright
        spike.rotation.x = 0;

        scene.add(spike);

        spikes.push({ mesh: spike });
    }
}
// Movement data (inactive until level > 25)
const moveDir = new THREE.Vector3(
    (Math.random() - 0.5),
    0,
    (Math.random() - 0.5)
).normalize();

const moveSpeed = 0.002 + (level * 0.00015); // gradually increases

spikes.push({
    mesh: spike,
    moveDir,
    moveSpeed
});

        function resetPlayerPosition() {
            player.position.set(
                Math.random() * 6 - 3,
                0.25,
                Math.random() * 6 - 3
            );
            velocity.set(0, 0, 0);
        }

        function showLevelIntro() {
            levelIntro.textContent = `LEVEL ${level}`;
            levelIntro.style.display = 'block';
            setTimeout(() => {
                levelIntro.style.display = 'none';
            }, 500);
        }

        function resetLevel() {
            createSpikesForLevel();
            resetPlayerPosition();

            invincible = true;
            if (invincibleTimeout) clearTimeout(invincibleTimeout);
            invincibleTimeout = setTimeout(() => {
                invincible = false;
            }, 500);

            levelStartTime = performance.now();
            updateHUD();

            showLevelIntro();
        }

        resetLevel();

        // Controls
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            KeyW: false, KeyS: false, KeyA: false, KeyD: false,
            Space: false
        };

        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = false;
                e.preventDefault();
            }
        });

        function tryDash() {
            const now = performance.now();
            if (dashCooldown > now) return;

            if (lastMoveDir.lengthSq() < 0.0001) return;

            const dashVec = lastMoveDir.clone().normalize().multiplyScalar(dashStrength);
            velocity.add(dashVec);
            dashCooldown = now + dashCooldownTime;
        }

        function movePlayer(deltaMs) {
            let inputX = 0;
            let inputZ = 0;

            if (keys.ArrowUp || keys.KeyW) inputZ -= 1;
            if (keys.ArrowDown || keys.KeyS) inputZ += 1;
            if (keys.ArrowLeft || keys.KeyA) inputX -= 1;
            if (keys.ArrowRight || keys.KeyD) inputX += 1;

            const inputVec = new THREE.Vector3(inputX, 0, inputZ);
            if (inputVec.lengthSq() > 0) {
                inputVec.normalize();
                lastMoveDir.copy(inputVec);

                velocity.x += inputVec.x * accel * deltaMs;
                velocity.z += inputVec.z * accel * deltaMs;
            }

            velocity.multiplyScalar(Math.pow(friction, deltaMs / 16.67));

            const speedSq = velocity.lengthSq();
            if (speedSq > maxSpeed * maxSpeed) {
                velocity.multiplyScalar(maxSpeed / Math.sqrt(speedSq));
            }

            player.position.add(velocity);

            const limit = 7;
            player.position.x = Math.max(-limit, Math.min(limit, player.position.x));
            player.position.z = Math.max(-limit, Math.min(limit, player.position.z));

            if (keys.Space) {
                tryDash();
                keys.Space = false;
            }
        }

        function updateSpikes(deltaMs, elapsed) {
            for (const s of spikes) {
                const mesh = s.mesh;
                if (s.type === 'slideX') {
                    const offset = Math.sin(elapsed * s.speed + s.phase) * s.amplitude;
                    mesh.position.x = s.basePos.x + offset;
                } else if (s.type === 'slideZ') {
                    const offset = Math.cos(elapsed * s.speed + s.phase) * s.amplitude;
                    mesh.position.z = s.basePos.z + offset;
                } else if (s.type === 'rotate') {
                    mesh.rotation.y += 0.003 * (1 + level * 0.05);
                }
            }
        }

        const baseCameraOffset = new THREE.Vector3(0, 4, 6);

        function updateCamera(deltaMs) {
            const desiredPosition = new THREE.Vector3(
                player.position.x + baseCameraOffset.x,
                player.position.y + baseCameraOffset.y,
                player.position.z + baseCameraOffset.z
            );

            camera.position.lerp(desiredPosition, 0.1);

            const tiltMax = 0.18;
            const tiltX = THREE.MathUtils.clamp(-velocity.z * 4, -tiltMax, tiltMax);
            const tiltZ = THREE.MathUtils.clamp(velocity.x * 4, -tiltMax, tiltMax);

            camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, tiltX, 0.15);
            camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, tiltZ, 0.15);

            let shakeOffset = new THREE.Vector3(0, 0, 0);
            if (shakeTime > 0) {
                const t = shakeTime / shakeDuration;
                const intensity = shakeIntensity * t;
                shakeOffset.set(
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity
                );
                shakeTime -= deltaMs;
            }

            camera.position.add(shakeOffset);
            camera.lookAt(player.position);
        }

        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaMs = now - lastTime;
            lastTime = now;

            movePlayer(deltaMs);

            const elapsed = now * 0.001;
            updateSpikes(deltaMs, elapsed);

            for (const s of spikes) {
                const spike = s.mesh;
                if (player.position.distanceTo(spike.position) < 0.5 && !invincible) {
                    shakeTime = shakeDuration;
                    document.getElementById('message').style.display = 'block';
                    renderer.domElement.style.display = 'none';
                    return;
                }
            }

            if (player.position.distanceTo(target.position) < 0.5) {
                const timeTaken = performance.now() - levelStartTime;
                const earned = Math.max(0, Math.floor(5000 / timeTaken));
                points += earned;

                level++;
                if (level > maxLevel) {
                    document.getElementById('completeMessage').style.display = 'block';
                    renderer.domElement.style.display = 'none';
                } else {
                    resetLevel();
                }
            }

            updateCamera(deltaMs);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>




