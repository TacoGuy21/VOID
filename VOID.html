<!DOCTYPE html>
<html lang="en">
<head>
      <link rel="icon" href="voidicon.png" type="image/png">
  <audio src="mary.mp3" autoplay loop></audio>
  <audio id="boys-audio" src="boys.mp3" loop></audio>

<script>
document.addEventListener('DOMContentLoaded', () => {
    let inputBuffer = '';
    const targetKeyword = 'gay';
    const audioElement = document.getElementById('boys-audio');

    function playAudio() {
        document.querySelectorAll('audio').forEach(audio => {
            if (audio !== audioElement) {
                audio.pause();
                audio.currentTime = 0;
            }
        });

        audioElement.play();
        audioElement.loop = true;
    }

    document.addEventListener('keydown', (event) => {
        inputBuffer += event.key.toLowerCase();

        if (inputBuffer.length > targetKeyword.length) {
            inputBuffer = inputBuffer.slice(-targetKeyword.length);
        }

        if (inputBuffer === targetKeyword) {
            playAudio();
        }
    });
});
</script>

<meta property="og:title" content="VOID">
<meta property="og:description" content="A 3D web experience by Tacoguy21">
<meta property="og:image" content="Spaceship.png">
<meta property="og:url" content="https://tacovoidgame.netlify.app/">
<link rel="icon" href="voidlogo.png" type="image/png">

<style>
    p, h2 { font-family: 'Space Mono', monospace; }

    .fake-popup {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 200px; padding: 10px;
      background-color: rgb(50, 50, 50);
      color: rgb(200, 200, 200);
      border: 7px solid rgb(80, 0, 0);
      border-radius: 5px;
      text-align: center;
      display: none;
    }
    .close-btn {
      position: absolute;
      top: 5px; right: 5px;
      cursor: pointer;
      color: rgb(255, 100, 100);
    }
</style>
</head>

<body>

<!-- HUD -->
<div id="hud" style="
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 22px;
    color: white;
    font-family: monospace;">
    Level: 1 | Points: 0
</div>

<div class="fake-popup" id="popup">
    <span class="close-btn" onclick="hidePopup()">X</span>
    <h2>Important Message</h2>
    <p>You are the grey cube</p>
    <p>Avoid the spikes and get to the green thing</p>
    <p>You have 0.5 seconds of invincibility at the beginning of each stage</p>
    <p>(There are 13 stages)</p>
    <p>Use your invincibility wisely</p>
    <p>Arrows or WASD to move</p>
    <p>When dead click the red text to revive</p>
    <p>Remember to think outside the box</p>
    <p>You may close.</p>
</div>

<script>
function showPopup() {
  var popup = document.getElementById('popup');
  var bodyRect = document.body.getBoundingClientRect();
  var leftPos = bodyRect.width / 2 + (Math.random() - 0.5) * (bodyRect.width / 4);
  var topPos = bodyRect.height / 2 + (Math.random() - 0.5) * (bodyRect.height / 4);
  popup.style.left = leftPos + 'px';
  popup.style.top = topPos + 'px';
  popup.style.display = 'block';
}
function hidePopup() { document.getElementById('popup').style.display = 'none'; }
window.onload = showPopup;
</script>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VOID</title>

<style>
    body {
        margin: 0;
        overflow: hidden;
        font-family: monospace, serif;
        background: #000;
        color: #fff;
    }
    #message, #completeMessage {
        display: none;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
    }
    #message { color: rgb(255, 50, 50); }
    #completeMessage { color: rgb(100, 100, 255); }
</style>

<div id="message" style="cursor: pointer;" onclick="location.reload();">failed.</div>
<div id="completeMessage">complete.</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

// ⭐ NEW CAMERA START POSITION ⭐
camera.position.set(0, 4, 6);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(0, 1, 1).normalize();
scene.add(light);

const playerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xbbbbbb });
const player = new THREE.Mesh(playerGeometry, playerMaterial);
scene.add(player);

const targetGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const targetMaterial = new THREE.MeshPhongMaterial({ color: 0x66ff66 });
const target = new THREE.Mesh(targetGeometry, targetMaterial);
target.position.set(0, 0.25, -2.5);
scene.add(target);

let spikes = [];

let level = 1;
const maxLevel = 15;

let points = 0;
let levelStartTime = 0;

function updateHUD() {
    document.getElementById("hud").textContent =
        `Level: ${level} | Points: ${points}`;
}

function isValidSpikePosition(position) {
    return player.position.distanceTo(position) > 1.0;
}

let invincible = false;
let invincibleTimeout = null;

function resetLevel() {
    spikes.forEach(spike => scene.remove(spike));
    spikes = [];

    const spikeCount = 1 + (level - 1);
    for (let i = 0; i < spikeCount; i++) {
        let spikePosition;
        do {
            spikePosition = new THREE.Vector3(Math.random() * 6 - 3, 0.5, Math.random() * 6 - 3);
        } while (!isValidSpikePosition(spikePosition));

        const spikeGeometry = new THREE.ConeGeometry(0.2, 1, 32);
        const spikeMaterial = new THREE.MeshPhongMaterial({ color: 0xAE4305});
        const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
        spike.position.copy(spikePosition);
        spikes.push(spike);
        scene.add(spike);
    }

    player.position.set(Math.random() * 6 - 3, 0.25, Math.random() * 6 - 3);

    invincible = true;
    invincibleTimeout = setTimeout(() => invincible = false, 500);

    levelStartTime = performance.now();
    updateHUD();
}

resetLevel();

const speed = 0.07;
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, KeyW: false, KeyS: false, KeyA: false, KeyD: false };

document.addEventListener('keydown', (e) => keys[e.code] = true);
document.addEventListener('keyup', (e) => keys[e.code] = false);

function movePlayer() {
    if (keys.ArrowUp || keys.KeyW) player.position.z -= speed;
    if (keys.ArrowDown || keys.KeyS) player.position.z += speed;
    if (keys.ArrowLeft || keys.KeyA) player.position.x -= speed;
    if (keys.ArrowRight || keys.KeyD) player.position.x += speed;
}

function animate() {
    requestAnimationFrame(animate);

    movePlayer();

    spikes.forEach(spike => {
        if (player.position.distanceTo(spike.position) < 0.5 && !invincible) {
            document.getElementById('message').style.display = 'block';
            renderer.domElement.style.display = 'none';
        }
    });

    if (player.position.distanceTo(target.position) < 0.5) {
        const timeTaken = performance.now() - levelStartTime;
        const earned = Math.max(0, Math.floor(5000 / timeTaken));
        points += earned;

        level++;

        if (level > maxLevel) {
            document.getElementById('completeMessage').style.display = 'block';
            renderer.domElement.style.display = 'none';
        } else {
            resetLevel();
        }
    }

    // ⭐ SMOOTH FOLLOW CAMERA ⭐
    const desiredPosition = new THREE.Vector3(
        player.position.x,
        player.position.y + 4,
        player.position.z + 6
    );

    camera.position.lerp(desiredPosition, 0.1);
    camera.lookAt(player.position);

    renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
x
