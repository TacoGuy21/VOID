<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="voidicon.png" type="image/png">
    <audio src="mary.mp3" autoplay loop></audio>
    <audio id="boys-audio" src="boys.mp3" loop></audio>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let inputBuffer = '';
        const targetKeyword = 'gay';
        const audioElement = document.getElementById('boys-audio');

        function playAudio() {
            document.querySelectorAll('audio').forEach(audio => {
                if (audio !== audioElement) {
                    audio.pause();
                    audio.currentTime = 0;
                }
            });

            audioElement.play();
            audioElement.loop = true;
        }

        document.addEventListener('keydown', (event) => {
            inputBuffer += event.key.toLowerCase();

            if (inputBuffer.length > targetKeyword.length) {
                inputBuffer = inputBuffer.slice(-targetKeyword.length);
            }

            if (inputBuffer === targetKeyword) {
                playAudio();
            }
        });
    });
    </script>

    <meta property="og:title" content="VOID">
    <meta property="og:description" content="A 3D web experience by Tacoguy21">
    <meta property="og:image" content="Spaceship.png">
    <meta property="og:url" content="https://tacovoidgame.netlify.app/">
    <link rel="icon" href="voidlogo.png" type="image/png">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Space Mono', monospace;
            background: #000000;
            color: #ffffff;
        }

        p, h2 {
            font-family: 'Space Mono', monospace;
        }

        .fake-popup {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 260px;
            padding: 12px;
            background-color: rgb(20, 20, 20);
            color: rgb(220, 220, 220);
            border: 7px solid rgb(80, 0, 0);
            border-radius: 5px;
            text-align: center;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .close-btn {
            position: absolute;
            top: 5px; right: 5px;
            cursor: pointer;
            color: rgb(255, 100, 100);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            z-index: 5;
        }

        #message, #completeMessage {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            z-index: 10;
        }

        #message {
            color: rgb(255, 50, 50);
            cursor: pointer;
        }

        #completeMessage {
            color: rgb(120, 140, 255);
        }

        #levelIntro {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0,0,0,0.9);
            display: none;
            z-index: 8;
        }

        #flashOverlay {
            position: fixed;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9;
            transition: opacity 0.15s linear;
        }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud">Level: 1 | Points: 0</div>

    <!-- Intro popup -->
    <div class="fake-popup" id="popup">
        <span class="close-btn" onclick="hidePopup()">X</span>
        <h2>Important Message</h2>
        <p>You are the grey cube</p>
        <p>Avoid the spikes and get to the green thing</p>
        <p>You have 0.5 seconds of invincibility at the beginning of each stage</p>
        <p>(There are 13 stages)</p>
        <p>Use your invincibility wisely</p>
        <p>Arrows or WASD to move</p>
        <p>Press SPACE to dash</p>
        <p>When dead click the red text to revive</p>
        <p>Remember to think outside the box</p>
        <p>You may close.</p>
    </div>

    <!-- Level intro text -->
    <div id="levelIntro">LEVEL 1</div>

    <!-- Flash overlay for hits -->
    <div id="flashOverlay"></div>

    <!-- Fail / complete messages -->
    <div id="message" onclick="location.reload();">failed.</div>
    <div id="completeMessage">complete.</div>

    <script>
    function showPopup() {
        var popup = document.getElementById('popup');
        var bodyRect = document.body.getBoundingClientRect();
        var leftPos = bodyRect.width / 2 + (Math.random() - 0.5) * (bodyRect.width / 4);
        var topPos = bodyRect.height / 2 + (Math.random() - 0.5) * (bodyRect.height / 4);
        popup.style.left = leftPos + 'px';
        popup.style.top = topPos + 'px';
        popup.style.display = 'block';
    }
    function hidePopup() {
        document.getElementById('popup').style.display = 'none';
    }
    window.onload = showPopup;
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Basic scene setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Soft fog for atmosphere
        scene.fog = new THREE.FogExp2(0x000000, 0.08);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting: ambient + directional
        const ambientLight = new THREE.AmbientLight(0x404060, 1.2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
        dirLight.position.set(4, 8, 6);
        dirLight.castShadow = false;
        scene.add(dirLight);

        // Floor grid
        const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        // --- Player & target ---
        const playerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const playerMaterial = new THREE.MeshPhongMaterial({
            color: 0xbbbbbb,
            emissive: 0x222222,
            shininess: 80
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.25;
        scene.add(player);

        const targetGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const targetMaterial = new THREE.MeshPhongMaterial({
            color: 0x66ff66,
            emissive: 0x113311,
            shininess: 100
        });
        const target = new THREE.Mesh(targetGeometry, targetMaterial);
        target.position.set(0, 0.25, -2.5);
        scene.add(target);

        let spikes = [];

        // --- Game state ---
        let level = 1;
        const maxLevel = 15;

        let points = 0;
        let levelStartTime = 0;

        let invincible = false;
        let invincibleTimeout = null;

        let canMove = false;       // level intro freeze
        let dashCooldown = 0;      // ms
        const dashCooldownTime = 1200;
        const dashStrength = 0.22;

        // Movement w/ acceleration
        const velocity = new THREE.Vector3(0, 0, 0);
        const accel = 0.009;
        const maxSpeed = 0.12;
        const friction = 0.82;
        let lastMoveDir = new THREE.Vector3(0, 0, -1);

        // Screen shake
        let shakeTime = 0;
        const shakeDuration = 200; // ms
        const shakeIntensity = 0.12;

        // HUD & UI refs
        const hud = document.getElementById('hud');
        const levelIntro = document.getElementById('levelIntro');
        const flashOverlay = document.getElementById('flashOverlay');

        function updateHUD() {
            hud.textContent = `Level: ${level} | Points: ${points}`;
        }

        function isValidSpikePosition(position) {
            return player.position.distanceTo(position) > 1.0;
        }

        // --- Spike creation w/ predictable patterns ---
        function createSpikesForLevel() {
            spikes.forEach(s => scene.remove(s.mesh));
            spikes = [];

            const baseCount = 2 + (level - 1);
            const spikeCount = Math.min(baseCount, 18);

            for (let i = 0; i < spikeCount; i++) {
                let spikePosition;
                do {
                    spikePosition = new THREE.Vector3(
                        Math.random() * 10 - 5,
                        0.5,
                        Math.random() * 10 - 5
                    );
                } while (!isValidSpikePosition(spikePosition));

                const spikeGeometry = new THREE.ConeGeometry(0.22, 0.9, 24);
                const spikeMaterial = new THREE.MeshPhongMaterial({
                    color: 0xAE4305,
                    emissive: 0x331000,
                    shininess: 60
                });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                spike.position.copy(spikePosition);
                spike.rotation.x = Math.PI; // point up
                scene.add(spike);

                // Decide type: static, sliding, rotating (predictable)
                let type = 'static';
                if (i % 4 === 1) type = 'slideX';
                else if (i % 4 === 2) type = 'slideZ';
                else if (i % 4 === 3) type = 'rotate';

                const data = {
                    mesh: spike,
                    type,
                    basePos: spikePosition.clone(),
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.0015 + level * 0.0002,
                    amplitude: 0.8 + (level * 0.02)
                };

                spikes.push(data);
            }
        }

        function resetPlayerPosition() {
            player.position.set(
                Math.random() * 6 - 3,
                0.25,
                Math.random() * 6 - 3
            );
            velocity.set(0, 0, 0);
        }

        function showLevelIntro() {
            levelIntro.textContent = `LEVEL ${level}`;
            levelIntro.style.display = 'block';
            setTimeout(() => {
                levelIntro.style.display = 'none';
                canMove = true;
            }, 300);
        }

        function resetLevel() {
            createSpikesForLevel();
            resetPlayerPosition();

            invincible = true;
            if (invincibleTimeout) clearTimeout(invincibleTimeout);
            invincibleTimeout = setTimeout(() => {
                invincible = false;
            }, 500);

            levelStartTime = performance.now();
            updateHUD();

            canMove = false;
            showLevelIntro();
        }

        resetLevel();

        // --- Controls ---
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            KeyW: false, KeyS: false, KeyA: false, KeyD: false,
            Space: false
        };

        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = false;
                e.preventDefault();
            }
        });

        // Dash trigger
        function tryDash() {
            if (!canMove) return;
            const now = performance.now();
            if (dashCooldown > now) return;

            if (lastMoveDir.lengthSq() < 0.0001) return;

            const dashVec = lastMoveDir.clone().normalize().multiplyScalar(dashStrength);
            velocity.add(dashVec);
            dashCooldown = now + dashCooldownTime;
        }

        // --- Movement w/ acceleration ---
        function movePlayer(deltaMs) {
            if (!canMove) return;

            let inputX = 0;
            let inputZ = 0;

            if (keys.ArrowUp || keys.KeyW) inputZ -= 1;
            if (keys.ArrowDown || keys.KeyS) inputZ += 1;
            if (keys.ArrowLeft || keys.KeyA) inputX -= 1;
            if (keys.ArrowRight || keys.KeyD) inputX += 1;

            const inputVec = new THREE.Vector3(inputX, 0, inputZ);
            if (inputVec.lengthSq() > 0) {
                inputVec.normalize();
                lastMoveDir.copy(inputVec);

                velocity.x += inputVec.x * accel * deltaMs;
                velocity.z += inputVec.z * accel * deltaMs;
            }

            // Friction
            velocity.multiplyScalar(Math.pow(friction, deltaMs / 16.67));

            // Clamp speed
            const speedSq = velocity.lengthSq();
            if (speedSq > maxSpeed * maxSpeed) {
                velocity.multiplyScalar(maxSpeed / Math.sqrt(speedSq));
            }

            // Apply velocity
            player.position.add(velocity);

            // Simple bounds
            const limit = 7;
            player.position.x = Math.max(-limit, Math.min(limit, player.position.x));
            player.position.z = Math.max(-limit, Math.min(limit, player.position.z));

            // Dash on Space
            if (keys.Space) {
                tryDash();
                // prevent holding to spam checks; dash is still gated by cooldown
                keys.Space = false;
            }
        }

        // --- Spike update (predictable motion) ---
        function updateSpikes(deltaMs, elapsed) {
            for (const s of spikes) {
                const mesh = s.mesh;
                if (s.type === 'slideX') {
                    const offset = Math.sin(elapsed * s.speed + s.phase) * s.amplitude;
                    mesh.position.x = s.basePos.x + offset;
                } else if (s.type === 'slideZ') {
                    const offset = Math.cos(elapsed * s.speed + s.phase) * s.amplitude;
                    mesh.position.z = s.basePos.z + offset;
                } else if (s.type === 'rotate') {
                    mesh.rotation.y += 0.003 * (1 + level * 0.05);
                }
            }
        }

        // --- Hit feedback ---
        function triggerHitEffects() {
            // Flash
            flashOverlay.style.opacity = 0.8;
            setTimeout(() => {
                flashOverlay.style.opacity = 0;
            }, 120);

            // Screen shake
            shakeTime = shakeDuration;
        }

        // --- Camera follow + tilt ---
        const baseCameraOffset = new THREE.Vector3(0, 4, 6);

        function updateCamera(deltaMs) {
            const desiredPosition = new THREE.Vector3(
                player.position.x + baseCameraOffset.x,
                player.position.y + baseCameraOffset.y,
                player.position.z + baseCameraOffset.z
            );

            camera.position.lerp(desiredPosition, 0.1);

            // Tilt based on velocity
            const tiltMax = 0.18;
            const tiltX = THREE.MathUtils.clamp(-velocity.z * 4, -tiltMax, tiltMax);
            const tiltZ = THREE.MathUtils.clamp(velocity.x * 4, -tiltMax, tiltMax);

            camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, tiltX, 0.15);
            camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, tiltZ, 0.15);

            // Screen shake overlay on camera position
            let shakeOffset = new THREE.Vector3(0, 0, 0);
            if (shakeTime > 0) {
                const t = shakeTime / shakeDuration;
                const intensity = shakeIntensity * t;
                shakeOffset.set(
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity
                );
                shakeTime -= deltaMs;
            }

            camera.position.add(shakeOffset);
            camera.lookAt(player.position);
        }

        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaMs = now - lastTime;
            lastTime = now;

            movePlayer(deltaMs);

            const elapsed = now * 0.001;
            updateSpikes(deltaMs, elapsed);

            // Collision with spikes
            for (const s of spikes) {
                const spike = s.mesh;
                if (player.position.distanceTo(spike.position) < 0.5 && !invincible) {
                    triggerHitEffects();
                    document.getElementById('message').style.display = 'block';
                    renderer.domElement.style.display = 'none';
                    return; // stop updating after death
                }
            }

            // Reach target
            if (player.position.distanceTo(target.position) < 0.5) {
                const timeTaken = performance.now() - levelStartTime;
                const earned = Math.max(0, Math.floor(5000 / timeTaken));
                points += earned;

                level++;
                if (level > maxLevel) {
                    document.getElementById('completeMessage').style.display = 'block';
                    renderer.domElement.style.display = 'none';
                } else {
                    resetLevel();
                }
            }

            updateCamera(deltaMs);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
