<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="voidicon.png" type="image/png">
    <audio src="mary.mp3" autoplay loop></audio>
    <audio id="boys-audio" src="boys.mp3" loop></audio>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let inputBuffer = '';
        const targetKeyword = 'gay';
        const audioElement = document.getElementById('boys-audio');

        function playAudio() {
            document.querySelectorAll('audio').forEach(audio => {
                if (audio !== audioElement) {
                    audio.pause();
                    audio.currentTime = 0;
                }
            });

            audioElement.play();
            audioElement.loop = true;
        }

        document.addEventListener('keydown', (event) => {
            inputBuffer += event.key.toLowerCase();

            if (inputBuffer.length > targetKeyword.length) {
                inputBuffer = inputBuffer.slice(-targetKeyword.length);
            }

            if (inputBuffer === targetKeyword) {
                playAudio();
            }
        });
    });
    </script>

    <meta property="og:title" content="VOID">
    <meta property="og:description" content="A 3D web experience by Tacoguy21">
    <meta property="og:image" content="Spaceship.png">
    <meta property="og:url" content="https://tacovoidgame.netlify.app/">
    <link rel="icon" href="voidlogo.png" type="image/png">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Space Mono', monospace;
            background: #000000;
            color: #ffffff;
        }

        p, h2 {
            font-family: 'Space Mono', monospace;
        }

        .fake-popup {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 260px;
            padding: 12px;
            background-color: rgb(20, 20, 20);
            color: rgb(220, 220, 220);
            border: 7px solid rgb(80, 0, 0);
            border-radius: 5px;
            text-align: center;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .close-btn {
            position: absolute;
            top: 5px; right: 5px;
            cursor: pointer;
            color: rgb(255, 100, 100);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            z-index: 5;
        }

        #message, #completeMessage {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            z-index: 10;
        }

        #message {
            color: rgb(255, 50, 50);
            cursor: pointer;
        }

        #completeMessage {
            color: rgb(120, 140, 255);
        }

        #levelIntro {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0,0,0,0.9);
            display: none;
            z-index: 8;
        }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud">Level: 1 | Points: 0</div>

    <!-- Intro popup -->
    <div class="fake-popup" id="popup">
        <span class="close-btn" onclick="hidePopup()">X</span>
        <h2>Important Message</h2>

        <p>You are the grey cube</p>
        <p>Avoid the spikes and reach the green cube</p>
        <p>You have 0.5 seconds of invincibility at the start of each level</p>
        <p>There are 13 levels</p>
        <p>Use WASD or Arrow Keys to move</p>
        <p>Press SPACE to dash</p>
        <p>Spikes move in predictable patterns</p>
        <p>They will never spawn on top of you</p>
        <p>Click the red text to revive when dead</p>
        <p>You may close.</p>
    </div>

    <!-- Level intro text -->
    <div id="levelIntro">LEVEL 1</div>

    <!-- Fail / complete messages -->
    <div id="message" onclick="location.reload();">failed.</div>
    <div id="completeMessage">complete.</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* ============================================================
   CONSTANTS & GLOBALS
============================================================ */
const SAFE_RADIUS = 1.2;
const ARENA_LIMIT = 7;

/* ============================================================
   SCENE SETUP
============================================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.08);

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.set(0, 4, 6);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ============================================================
   LIGHTING
============================================================ */
scene.add(new THREE.AmbientLight(0x404060, 1.2));

const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
dirLight.position.set(4, 8, 6);
scene.add(dirLight);

/* ============================================================
   FLOOR GRID
============================================================ */
const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
gridHelper.position.y = 0;
scene.add(gridHelper);

/* ============================================================
   PLAYER
============================================================ */
const player = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshPhongMaterial({
        color: 0xbbbbbb,
        emissive: 0x222222,
        shininess: 80
    })
);
player.position.y = 0.25;
scene.add(player);

/* ============================================================
   TARGET
============================================================ */
const target = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshPhongMaterial({
        color: 0x66ff66,
        emissive: 0x113311,
        shininess: 100
    })
);
target.position.set(0, 0.25, -2.5);
scene.add(target);

/* ============================================================
   SAFE ZONE (STATIONARY)
============================================================ */
const ringGeometry = new THREE.RingGeometry(SAFE_RADIUS - 0.05, SAFE_RADIUS, 32);
const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0x66aaff,
    opacity: 0.35,
    transparent: true,
    side: THREE.DoubleSide
});
const safeRing = new THREE.Mesh(ringGeometry, ringMaterial);
safeRing.rotation.x = -Math.PI / 2;
safeRing.position.set(0, 0.01, 0);
scene.add(safeRing);

const safeLight = new THREE.PointLight(0x66aaff, 1.2, 3);
safeLight.position.set(0, 0.6, 0);
scene.add(safeLight);

/* ============================================================
   GAME STATE
============================================================ */
let spikes = [];
let level = 1;
const maxLevel = 50;
let points = 0;
let levelStartTime = 0;
let invincible = false;
let invincibleTimeout = null;

/* ============================================================
   PLAYER MOVEMENT PHYSICS
============================================================ */
const velocity = new THREE.Vector3(0, 0, 0);
const accel = 0.009;
const maxSpeed = 0.12;
const friction = 0.82;
let lastMoveDir = new THREE.Vector3(0, 0, -1);

/* DASH */
let dashCooldown = 0;
const dashCooldownTime = 1200;
const dashStrength = 0.22;

/* CAMERA SHAKE */
let shakeTime = 0;
const shakeDuration = 200;
const shakeIntensity = 0.12;

/* HUD */
const hud = document.getElementById("hud");
const levelIntro = document.getElementById("levelIntro");

function updateHUD() {
    hud.textContent = `Level: ${level} | Points: ${points}`;
}

/* ============================================================
   SAFE SPAWN CHECK
============================================================ */
function isValidSpikePosition(position) {
    const distToSpawn = position.length();
    const distToTarget = target.position.distanceTo(position);

    return (
        distToSpawn > SAFE_RADIUS + 0.8 &&
        distToTarget > 1.5
    );
}

/* ============================================================
   SPIKE TYPES (EVERY 5 LEVELS)
============================================================ */
function getSpikeGeometryForLevel(level) {
    if (level <= 5) return new THREE.ConeGeometry(0.22, 0.9, 24);
    if (level <= 10) return new THREE.ConeGeometry(0.25, 1.3, 24);
    if (level <= 15) return new THREE.ConeGeometry(0.35, 0.9, 24);
    if (level <= 20) return new THREE.CylinderGeometry(0.22, 0.22, 1.2, 16);
    if (level <= 25) return new THREE.ConeGeometry(0.3, 1.1, 4);
    if (level <= 30) return new THREE.CylinderGeometry(0.18, 0.18, 0.8, 12);
    if (level <= 35) return new THREE.BoxGeometry(0.25, 1.4, 0.25);
    if (level <= 40) return new THREE.OctahedronGeometry(0.35);
    if (level <= 45) return new THREE.BoxGeometry(0.15, 1.6, 0.15);
    return new THREE.ConeGeometry(0.28, 1.4, 32);
}

function getSpikeMaterialForLevel(level) {
    if (level <= 45) {
        return new THREE.MeshPhongMaterial({
            color: 0xAE4305,
            emissive: 0x331000,
            shininess: 60
        });
    }
    return new THREE.MeshPhongMaterial({
        color: 0xff4444,
        emissive: 0x550000,
        shininess: 120
    });
}

/* ============================================================
   SPIKE COUNT CURVE
============================================================ */
function getSpikeCountForLevel(level) {
    if (level <= 10) return 3 + Math.floor(level * 0.5);
    if (level <= 20) return 8 + Math.floor((level - 10) * 0.7);
    if (level <= 35) return 15 + Math.floor((level - 20) * 0.6);
    return 24 + Math.floor((level - 35) * 0.5);
}

/* ============================================================
   CREATE SPIKES (ALWAYS MOVING)
============================================================ */
function createSpikesForLevel() {
    spikes.forEach(s => scene.remove(s.mesh));
    spikes = [];

    const spikeCount = Math.min(getSpikeCountForLevel(level), 32);

    for (let i = 0; i < spikeCount; i++) {
        let pos;
        let tries = 0;

        do {
            pos = new THREE.Vector3(
                Math.random() * 10 - 5,
                0.5,
                Math.random() * 10 - 5
            );
            tries++;
            if (tries > 100) break;
        } while (!isValidSpikePosition(pos));

        const spike = new THREE.Mesh(
            getSpikeGeometryForLevel(level),
            getSpikeMaterialForLevel(level)
        );
        spike.position.copy(pos);
        spike.rotation.x = 0;
        scene.add(spike);

        const moveDir = new THREE.Vector3(
            Math.random() - 0.5,
            0,
            Math.random() - 0.5
        ).normalize();

        let speed = 0.0025 + (level - 1) * 0.00012;
        if (level > 35) speed += (level - 35) * 0.00015;

        spikes.push({
            mesh: spike,
            moveDir,
            moveSpeed: speed
        });
    }
}

/* ============================================================
   PLAYER SPAWN
============================================================ */
function resetPlayerPosition() {
    // Always spawn in the center of the safe zone
    player.position.set(0, 0.25, 0);

    // Reset movement
    velocity.set(0, 0, 0);
}



/* ============================================================
   LEVEL RESET
============================================================ */
function showLevelIntro() {
    levelIntro.textContent = `LEVEL ${level}`;
    levelIntro.style.display = "block";
    setTimeout(() => levelIntro.style.display = "none", 500);
}

function resetLevel() {
    createSpikesForLevel();
    resetPlayerPosition();

    invincible = true;
    if (invincibleTimeout) clearTimeout(invincibleTimeout);
    invincibleTimeout = setTimeout(() => invincible = false, 500);

    levelStartTime = performance.now();
    updateHUD();
    showLevelIntro();
}

resetLevel();

/* ============================================================
   INPUT
============================================================ */
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    KeyW: false, KeyS: false, KeyA: false, KeyD: false,
    Space: false
};

document.addEventListener("keydown", e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
});
document.addEventListener("keyup", e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
});

/* ============================================================
   PLAYER MOVEMENT
============================================================ */
function tryDash() {
    const now = performance.now();
    if (dashCooldown > now) return;
    if (lastMoveDir.lengthSq() < 0.001) return;

    velocity.add(lastMoveDir.clone().normalize().multiplyScalar(dashStrength));
    dashCooldown = now + dashCooldownTime;
}

function movePlayer(deltaMs) {
    let x = 0, z = 0;

    if (keys.KeyW || keys.ArrowUp) z -= 1;
    if (keys.KeyS || keys.ArrowDown) z += 1;
    if (keys.KeyA || keys.ArrowLeft) x -= 1;
    if (keys.KeyD || keys.ArrowRight) x += 1;

    const input = new THREE.Vector3(x, 0, z);
    if (input.lengthSq() > 0) {
        input.normalize();
        lastMoveDir.copy(input);
        velocity.x += input.x * accel * deltaMs;
        velocity.z += input.z * accel * deltaMs;
    }

    velocity.multiplyScalar(Math.pow(friction, deltaMs / 16.67));

    if (velocity.lengthSq() > maxSpeed * maxSpeed) {
        velocity.multiplyScalar(maxSpeed / velocity.length());
    }

    player.position.add(velocity);

    player.position.x = Math.max(-ARENA_LIMIT, Math.min(ARENA_LIMIT, player.position.x));
    player.position.z = Math.max(-ARENA_LIMIT, Math.min(ARENA_LIMIT, player.position.z));

    if (keys.Space) {
        tryDash();
        keys.Space = false;
    }
}

/* ============================================================
   SPIKE MOVEMENT (ALWAYS MOVING)
============================================================ */
function updateSpikeMovement(deltaMs) {
    for (const s of spikes) {
        const spike = s.mesh;

        const dx = s.moveDir.x * s.moveSpeed * deltaMs;
        const dz = s.moveDir.z * s.moveSpeed * deltaMs;

        const next = new THREE.Vector3(
            spike.position.x + dx,
            spike.position.y,
            spike.position.z + dz
        );

        if (next.x < -ARENA_LIMIT || next.x > ARENA_LIMIT) s.moveDir.x *= -1;
        if (next.z < -ARENA_LIMIT || next.z > ARENA_LIMIT) s.moveDir.z *= -1;

        const finalPos = new THREE.Vector3(
            spike.position.x + s.moveDir.x * s.moveSpeed * deltaMs,
            spike.position.y,
            spike.position.z + s.moveDir.z * s.moveSpeed * deltaMs
        );

        if (finalPos.length() < SAFE_RADIUS + 0.2) {
            s.moveDir.multiplyScalar(-1);
        } else {
            spike.position.copy(finalPos);
        }
    }
}

/* ============================================================
   CAMERA
============================================================ */
const baseCameraOffset = new THREE.Vector3(0, 4, 6);

function updateCamera(deltaMs) {
    const desired = new THREE.Vector3(
        player.position.x + baseCameraOffset.x,
        player.position.y + baseCameraOffset.y,
        player.position.z + baseCameraOffset.z
    );

    camera.position.lerp(desired, 0.1);

    const tiltMax = 0.18;
    camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, -velocity.z * 4, 0.15);
    camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, velocity.x * 4, 0.15);

    if (shakeTime > 0) {
        const t = shakeTime / shakeDuration;
        const intensity = shakeIntensity * t;
        camera.position.x += (Math.random() - 0.5) * intensity;
        camera.position.y += (Math.random() - 0.5) * intensity;
        shakeTime -= deltaMs;
    }

    camera.lookAt(player.position);
}

/* ============================================================
   MAIN LOOP
============================================================ */
let lastTime = performance.now();

function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const deltaMs = now - lastTime;
    lastTime = now;

    movePlayer(deltaMs);
    updateSpikeMovement(deltaMs);

    for (const s of spikes) {
        if (player.position.distanceTo(s.mesh.position) < 0.5 && !invincible) {
            shakeTime = shakeDuration;
            document.getElementById("message").style.display = "block";
            renderer.domElement.style.display = "none";
            return;
        }
    }

    if (player.position.distanceTo(target.position) < 0.5) {
        const timeTaken = performance.now() - levelStartTime;
        points += Math.max(0, Math.floor(5000 / timeTaken));

        level++;
        if (level > maxLevel) {
            document.getElementById("completeMessage").style.display = "block";
            renderer.domElement.style.display = "none";
        } else {
            resetLevel();
        }
    }

    updateCamera(deltaMs);
    renderer.render(scene, camera);
}

animate();

/* ============================================================
   RESIZE HANDLER
============================================================ */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>


    <script>
    function showPopup() {
        var popup = document.getElementById('popup');
        var bodyRect = document.body.getBoundingClientRect();
        var leftPos = bodyRect.width / 2 + (Math.random() - 0.5) * (bodyRect.width / 4);
        var topPos = bodyRect.height / 2 + (Math.random() - 0.5) * (bodyRect.height / 4);
        popup.style.left = leftPos + 'px';
        popup.style.top = topPos + 'px';
        popup.style.display = 'block';
    }
    function hidePopup() {
        document.getElementById('popup').style.display = 'none';
    }
    window.onload = showPopup;
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Scene setup ---
        const SAFE_RADIUS = 1.2; // small, tight, always clear

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.08);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 1.2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
        dirLight.position.set(4, 8, 6);
        scene.add(dirLight);

        // Grid floor
        const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        // Player
        const playerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const playerMaterial = new THREE.MeshPhongMaterial({
            color: 0xbbbbbb,
            emissive: 0x222222,
            shininess: 80
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.25;
        scene.add(player);

        // Target
        const targetGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const targetMaterial = new THREE.MeshPhongMaterial({
            color: 0x66ff66,
            emissive: 0x113311,
            shininess: 100
        });
        const target = new THREE.Mesh(targetGeometry, targetMaterial);
        target.position.set(0, 0.25, -2.5);
        scene.add(target);

        let spikes = [];

        // Game state
        let level = 1;
        const maxLevel = 50;

        let points = 0;
        let levelStartTime = 0;

        let invincible = false;
        let invincibleTimeout = null;

        // Movement physics
        const velocity = new THREE.Vector3(0, 0, 0);
        const accel = 0.009;
        const maxSpeed = 0.12;
        const friction = 0.82;
        let lastMoveDir = new THREE.Vector3(0, 0, -1);

        // Dash
        let dashCooldown = 0;
        const dashCooldownTime = 1200;
        const dashStrength = 0.22;

        // Camera shake
        let shakeTime = 0;
        const shakeDuration = 200;
        const shakeIntensity = 0.12;

        const hud = document.getElementById('hud');
        const levelIntro = document.getElementById('levelIntro');

        function updateHUD() {
            hud.textContent = `Level: ${level} | Points: ${points}`;
        }

        // Prevent spikes spawning on player or target
       function isValidSpikePosition(position) {
    const distToPlayer = player.position.distanceTo(position);
    const distToTarget = target.position.distanceTo(position);

    return (
        distToPlayer > SAFE_RADIUS + 0.8 &&   // guaranteed buffer
        distToTarget > 1.5
    );
}


        // Predictable spike patterns
function createSpikesForLevel() {
    spikes.forEach(s => scene.remove(s.mesh));
    spikes = [];

    let spikeCount;

    if (level <= 10) {
        spikeCount = 3 + Math.floor(level * 0.5);
    } else if (level <= 20) {
        spikeCount = 8 + Math.floor((level - 10) * 0.7);
    } else if (level <= 35) {
        spikeCount = 15 + Math.floor((level - 20) * 0.6);
    } else {
        spikeCount = 24 + Math.floor((level - 35) * 0.5);
    }

    spikeCount = Math.min(spikeCount, 32);

    for (let i = 0; i < spikeCount; i++) {
        let spikePosition;
        do {
            spikePosition = new THREE.Vector3(
                Math.random() * 10 - 5,
                0.5,
                Math.random() * 10 - 5
            );
        } while (!isValidSpikePosition(spikePosition));

        // --- SPIKE TYPE SELECTION ---
        let geometry;
        let material = new THREE.MeshPhongMaterial({
            color: 0xAE4305,
            emissive: 0x331000,
            shininess: 60
        });

        if (level <= 5) {
            geometry = new THREE.ConeGeometry(0.22, 0.9, 24);
        } else if (level <= 10) {
            geometry = new THREE.ConeGeometry(0.25, 1.3, 24);
        } else if (level <= 15) {
            geometry = new THREE.ConeGeometry(0.35, 0.9, 24);
        } else if (level <= 20) {
            geometry = new THREE.CylinderGeometry(0.22, 0.22, 1.2, 16);
        } else if (level <= 25) {
            geometry = new THREE.ConeGeometry(0.3, 1.1, 4);
        } else if (level <= 30) {
            geometry = new THREE.CylinderGeometry(0.18, 0.18, 0.8, 12);
        } else if (level <= 35) {
            geometry = new THREE.BoxGeometry(0.25, 1.4, 0.25);
        } else if (level <= 40) {
            geometry = new THREE.OctahedronGeometry(0.35);
        } else if (level <= 45) {
            geometry = new THREE.BoxGeometry(0.15, 1.6, 0.15);
        } else {
            geometry = new THREE.ConeGeometry(0.28, 1.4, 32);
            material = new THREE.MeshPhongMaterial({
                color: 0xff4444,
                emissive: 0x550000,
                shininess: 120
            });
        }

        const spike = new THREE.Mesh(geometry, material);
        spike.position.copy(spikePosition);

        // Flip spikes upright
        spike.rotation.x = 0;

        scene.add(spike);

        spikes.push({ mesh: spike });
    }
}

        function resetPlayerPosition() {
            player.position.set(
                Math.random() * 6 - 3,
                0.25,
                Math.random() * 6 - 3
            );
            velocity.set(0, 0, 0);
        }

        function showLevelIntro() {
            levelIntro.textContent = `LEVEL ${level}`;
            levelIntro.style.display = 'block';
            setTimeout(() => {
                levelIntro.style.display = 'none';
            }, 500);
        }

        function resetLevel() {
            createSpikesForLevel();
            resetPlayerPosition();

            invincible = true;
            if (invincibleTimeout) clearTimeout(invincibleTimeout);
            invincibleTimeout = setTimeout(() => {
                invincible = false;
            }, 500);

            levelStartTime = performance.now();
            updateHUD();

            showLevelIntro();
        }

        resetLevel();

        // Controls
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            KeyW: false, KeyS: false, KeyA: false, KeyD: false,
            Space: false
        };

        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = false;
                e.preventDefault();
            }
        });

        function tryDash() {
            const now = performance.now();
            if (dashCooldown > now) return;

            if (lastMoveDir.lengthSq() < 0.0001) return;

            const dashVec = lastMoveDir.clone().normalize().multiplyScalar(dashStrength);
            velocity.add(dashVec);
            dashCooldown = now + dashCooldownTime;
        }

        function movePlayer(deltaMs) {
            let inputX = 0;
            let inputZ = 0;

            if (keys.ArrowUp || keys.KeyW) inputZ -= 1;
            if (keys.ArrowDown || keys.KeyS) inputZ += 1;
            if (keys.ArrowLeft || keys.KeyA) inputX -= 1;
            if (keys.ArrowRight || keys.KeyD) inputX += 1;

            const inputVec = new THREE.Vector3(inputX, 0, inputZ);
            if (inputVec.lengthSq() > 0) {
                inputVec.normalize();
                lastMoveDir.copy(inputVec);

                velocity.x += inputVec.x * accel * deltaMs;
                velocity.z += inputVec.z * accel * deltaMs;
            }

            velocity.multiplyScalar(Math.pow(friction, deltaMs / 16.67));

            const speedSq = velocity.lengthSq();
            if (speedSq > maxSpeed * maxSpeed) {
                velocity.multiplyScalar(maxSpeed / Math.sqrt(speedSq));
            }

            player.position.add(velocity);

            const limit = 7;
            player.position.x = Math.max(-limit, Math.min(limit, player.position.x));
            player.position.z = Math.max(-limit, Math.min(limit, player.position.z));

            if (keys.Space) {
                tryDash();
                keys.Space = false;
            }
        }

        function updateSpikes(deltaMs, elapsed) {
            for (const s of spikes) {
                const mesh = s.mesh;
                if (s.type === 'slideX') {
                    const offset = Math.sin(elapsed * s.speed + s.phase) * s.amplitude;
                    mesh.position.x = s.basePos.x + offset;
                } else if (s.type === 'slideZ') {
                    const offset = Math.cos(elapsed * s.speed + s.phase) * s.amplitude;
                    mesh.position.z = s.basePos.z + offset;
                } else if (s.type === 'rotate') {
                    mesh.rotation.y += 0.003 * (1 + level * 0.05);
                }
            }
        }

        const baseCameraOffset = new THREE.Vector3(0, 4, 6);

        function updateCamera(deltaMs) {
            const desiredPosition = new THREE.Vector3(
                player.position.x + baseCameraOffset.x,
                player.position.y + baseCameraOffset.y,
                player.position.z + baseCameraOffset.z
            );

            camera.position.lerp(desiredPosition, 0.1);

            const tiltMax = 0.18;
            const tiltX = THREE.MathUtils.clamp(-velocity.z * 4, -tiltMax, tiltMax);
            const tiltZ = THREE.MathUtils.clamp(velocity.x * 4, -tiltMax, tiltMax);

            camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, tiltX, 0.15);
            camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, tiltZ, 0.15);

            let shakeOffset = new THREE.Vector3(0, 0, 0);
            if (shakeTime > 0) {
                const t = shakeTime / shakeDuration;
                const intensity = shakeIntensity * t;
                shakeOffset.set(
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity
                );
                shakeTime -= deltaMs;
            }

            camera.position.add(shakeOffset);
            camera.lookAt(player.position);
        }

        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaMs = now - lastTime;
            lastTime = now;

            movePlayer(deltaMs);

            const elapsed = now * 0.001;
            updateSpikes(deltaMs, elapsed);

            for (const s of spikes) {
                const spike = s.mesh;
                if (player.position.distanceTo(spike.position) < 0.5 && !invincible) {
                    shakeTime = shakeDuration;
                    document.getElementById('message').style.display = 'block';
                    renderer.domElement.style.display = 'none';
                    return;
                }
            }

            if (player.position.distanceTo(target.position) < 0.5) {
                const timeTaken = performance.now() - levelStartTime;
                const earned = Math.max(0, Math.floor(5000 / timeTaken));
                points += earned;

                level++;
                if (level > maxLevel) {
                    document.getElementById('completeMessage').style.display = 'block';
                    renderer.domElement.style.display = 'none';
                } else {
                    resetLevel();
                }
            }

            updateCamera(deltaMs);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

